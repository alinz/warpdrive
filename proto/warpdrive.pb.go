// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/warpdrive.proto

/*
Package warpdrive is a generated protocol buffer package.

It is generated from these files:
	proto/warpdrive.proto

It has these top-level messages:
	Credential
	Certificate
	Token
	App
	Release
	Bundle
	Chunck
*/
package warpdrive

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Platform int32

const (
	Platform_UNKNOWN Platform = 0
	Platform_IOS     Platform = 1
	Platform_ANDROID Platform = 2
)

var Platform_name = map[int32]string{
	0: "UNKNOWN",
	1: "IOS",
	2: "ANDROID",
}
var Platform_value = map[string]int32{
	"UNKNOWN": 0,
	"IOS":     1,
	"ANDROID": 2,
}

func (x Platform) String() string {
	return proto.EnumName(Platform_name, int32(x))
}
func (Platform) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Credential struct {
	Username string `protobuf:"bytes,1,opt,name=username" json:"username,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
	AppName  string `protobuf:"bytes,3,opt,name=appName" json:"appName,omitempty"`
}

func (m *Credential) Reset()                    { *m = Credential{} }
func (m *Credential) String() string            { return proto.CompactTextString(m) }
func (*Credential) ProtoMessage()               {}
func (*Credential) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Credential) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Credential) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Credential) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

type Certificate struct {
	// token is signed jwt of Token message
	Token string `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
	Cert  string `protobuf:"bytes,2,opt,name=cert" json:"cert,omitempty"`
	Addr  string `protobuf:"bytes,3,opt,name=addr" json:"addr,omitempty"`
}

func (m *Certificate) Reset()                    { *m = Certificate{} }
func (m *Certificate) String() string            { return proto.CompactTextString(m) }
func (*Certificate) ProtoMessage()               {}
func (*Certificate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Certificate) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *Certificate) GetCert() string {
	if m != nil {
		return m.Cert
	}
	return ""
}

func (m *Certificate) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type Token struct {
	Admin     bool   `protobuf:"varint,1,opt,name=admin" json:"admin,omitempty"`
	AppId     uint64 `protobuf:"varint,2,opt,name=appId" json:"appId,omitempty"`
	ReleaseId uint64 `protobuf:"varint,3,opt,name=releaseId" json:"releaseId,omitempty"`
}

func (m *Token) Reset()                    { *m = Token{} }
func (m *Token) String() string            { return proto.CompactTextString(m) }
func (*Token) ProtoMessage()               {}
func (*Token) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Token) GetAdmin() bool {
	if m != nil {
		return m.Admin
	}
	return false
}

func (m *Token) GetAppId() uint64 {
	if m != nil {
		return m.AppId
	}
	return 0
}

func (m *Token) GetReleaseId() uint64 {
	if m != nil {
		return m.ReleaseId
	}
	return 0
}

type App struct {
	// @inject_tag: storm:"id,increment"
	Id uint64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// @inject_tag: storm:"unique"
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
}

func (m *App) Reset()                    { *m = App{} }
func (m *App) String() string            { return proto.CompactTextString(m) }
func (*App) ProtoMessage()               {}
func (*App) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *App) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *App) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Release struct {
	// @inject_tag: storm:"id,increment"
	Id uint64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// @inject_tag: storm:"index"
	AppId uint64 `protobuf:"varint,2,opt,name=appId" json:"appId,omitempty"`
	Name  string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
}

func (m *Release) Reset()                    { *m = Release{} }
func (m *Release) String() string            { return proto.CompactTextString(m) }
func (*Release) ProtoMessage()               {}
func (*Release) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Release) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Release) GetAppId() uint64 {
	if m != nil {
		return m.AppId
	}
	return 0
}

func (m *Release) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Bundle struct {
	// @inject_tag: storm:"id,increment"
	Id uint64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// @inject_tag: storm:"index"
	ReleaseId uint64 `protobuf:"varint,2,opt,name=releaseId" json:"releaseId,omitempty"`
	// @inject_tag: storm:"index"
	Next     uint64   `protobuf:"varint,3,opt,name=next" json:"next,omitempty"`
	Platform Platform `protobuf:"varint,4,opt,name=platform,enum=warpdrive.Platform" json:"platform,omitempty"`
	Version  string   `protobuf:"bytes,5,opt,name=version" json:"version,omitempty"`
}

func (m *Bundle) Reset()                    { *m = Bundle{} }
func (m *Bundle) String() string            { return proto.CompactTextString(m) }
func (*Bundle) ProtoMessage()               {}
func (*Bundle) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Bundle) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Bundle) GetReleaseId() uint64 {
	if m != nil {
		return m.ReleaseId
	}
	return 0
}

func (m *Bundle) GetNext() uint64 {
	if m != nil {
		return m.Next
	}
	return 0
}

func (m *Bundle) GetPlatform() Platform {
	if m != nil {
		return m.Platform
	}
	return Platform_UNKNOWN
}

func (m *Bundle) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type Chunck struct {
	// Types that are valid to be assigned to Value:
	//	*Chunck_Bundle
	//	*Chunck_Data
	Value isChunck_Value `protobuf_oneof:"value"`
}

func (m *Chunck) Reset()                    { *m = Chunck{} }
func (m *Chunck) String() string            { return proto.CompactTextString(m) }
func (*Chunck) ProtoMessage()               {}
func (*Chunck) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isChunck_Value interface {
	isChunck_Value()
}

type Chunck_Bundle struct {
	Bundle *Bundle `protobuf:"bytes,1,opt,name=bundle,oneof"`
}
type Chunck_Data struct {
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3,oneof"`
}

func (*Chunck_Bundle) isChunck_Value() {}
func (*Chunck_Data) isChunck_Value()   {}

func (m *Chunck) GetValue() isChunck_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Chunck) GetBundle() *Bundle {
	if x, ok := m.GetValue().(*Chunck_Bundle); ok {
		return x.Bundle
	}
	return nil
}

func (m *Chunck) GetData() []byte {
	if x, ok := m.GetValue().(*Chunck_Data); ok {
		return x.Data
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Chunck) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Chunck_OneofMarshaler, _Chunck_OneofUnmarshaler, _Chunck_OneofSizer, []interface{}{
		(*Chunck_Bundle)(nil),
		(*Chunck_Data)(nil),
	}
}

func _Chunck_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Chunck)
	// value
	switch x := m.Value.(type) {
	case *Chunck_Bundle:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Bundle); err != nil {
			return err
		}
	case *Chunck_Data:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Data)
	case nil:
	default:
		return fmt.Errorf("Chunck.Value has unexpected type %T", x)
	}
	return nil
}

func _Chunck_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Chunck)
	switch tag {
	case 1: // value.bundle
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Bundle)
		err := b.DecodeMessage(msg)
		m.Value = &Chunck_Bundle{msg}
		return true, err
	case 2: // value.data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Value = &Chunck_Data{x}
		return true, err
	default:
		return false, nil
	}
}

func _Chunck_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Chunck)
	// value
	switch x := m.Value.(type) {
	case *Chunck_Bundle:
		s := proto.Size(x.Bundle)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Chunck_Data:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Data)))
		n += len(x.Data)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*Credential)(nil), "warpdrive.Credential")
	proto.RegisterType((*Certificate)(nil), "warpdrive.Certificate")
	proto.RegisterType((*Token)(nil), "warpdrive.Token")
	proto.RegisterType((*App)(nil), "warpdrive.App")
	proto.RegisterType((*Release)(nil), "warpdrive.Release")
	proto.RegisterType((*Bundle)(nil), "warpdrive.Bundle")
	proto.RegisterType((*Chunck)(nil), "warpdrive.Chunck")
	proto.RegisterEnum("warpdrive.Platform", Platform_name, Platform_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Warpdrive service

type WarpdriveClient interface {
	SetupApp(ctx context.Context, in *Credential, opts ...grpc.CallOption) (*Certificate, error)
	SetupReleaseAdminCertificate(ctx context.Context, in *Release, opts ...grpc.CallOption) (*Certificate, error)
	SetupReleaseUserCertificate(ctx context.Context, in *Release, opts ...grpc.CallOption) (*Certificate, error)
	Publish(ctx context.Context, opts ...grpc.CallOption) (Warpdrive_PublishClient, error)
	Download(ctx context.Context, in *Release, opts ...grpc.CallOption) (Warpdrive_DownloadClient, error)
}

type warpdriveClient struct {
	cc *grpc.ClientConn
}

func NewWarpdriveClient(cc *grpc.ClientConn) WarpdriveClient {
	return &warpdriveClient{cc}
}

func (c *warpdriveClient) SetupApp(ctx context.Context, in *Credential, opts ...grpc.CallOption) (*Certificate, error) {
	out := new(Certificate)
	err := grpc.Invoke(ctx, "/warpdrive.Warpdrive/setupApp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *warpdriveClient) SetupReleaseAdminCertificate(ctx context.Context, in *Release, opts ...grpc.CallOption) (*Certificate, error) {
	out := new(Certificate)
	err := grpc.Invoke(ctx, "/warpdrive.Warpdrive/setupReleaseAdminCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *warpdriveClient) SetupReleaseUserCertificate(ctx context.Context, in *Release, opts ...grpc.CallOption) (*Certificate, error) {
	out := new(Certificate)
	err := grpc.Invoke(ctx, "/warpdrive.Warpdrive/setupReleaseUserCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *warpdriveClient) Publish(ctx context.Context, opts ...grpc.CallOption) (Warpdrive_PublishClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Warpdrive_serviceDesc.Streams[0], c.cc, "/warpdrive.Warpdrive/publish", opts...)
	if err != nil {
		return nil, err
	}
	x := &warpdrivePublishClient{stream}
	return x, nil
}

type Warpdrive_PublishClient interface {
	Send(*Chunck) error
	CloseAndRecv() (*Bundle, error)
	grpc.ClientStream
}

type warpdrivePublishClient struct {
	grpc.ClientStream
}

func (x *warpdrivePublishClient) Send(m *Chunck) error {
	return x.ClientStream.SendMsg(m)
}

func (x *warpdrivePublishClient) CloseAndRecv() (*Bundle, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Bundle)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *warpdriveClient) Download(ctx context.Context, in *Release, opts ...grpc.CallOption) (Warpdrive_DownloadClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Warpdrive_serviceDesc.Streams[1], c.cc, "/warpdrive.Warpdrive/download", opts...)
	if err != nil {
		return nil, err
	}
	x := &warpdriveDownloadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Warpdrive_DownloadClient interface {
	Recv() (*Chunck, error)
	grpc.ClientStream
}

type warpdriveDownloadClient struct {
	grpc.ClientStream
}

func (x *warpdriveDownloadClient) Recv() (*Chunck, error) {
	m := new(Chunck)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Warpdrive service

type WarpdriveServer interface {
	SetupApp(context.Context, *Credential) (*Certificate, error)
	SetupReleaseAdminCertificate(context.Context, *Release) (*Certificate, error)
	SetupReleaseUserCertificate(context.Context, *Release) (*Certificate, error)
	Publish(Warpdrive_PublishServer) error
	Download(*Release, Warpdrive_DownloadServer) error
}

func RegisterWarpdriveServer(s *grpc.Server, srv WarpdriveServer) {
	s.RegisterService(&_Warpdrive_serviceDesc, srv)
}

func _Warpdrive_SetupApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Credential)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WarpdriveServer).SetupApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/warpdrive.Warpdrive/SetupApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WarpdriveServer).SetupApp(ctx, req.(*Credential))
	}
	return interceptor(ctx, in, info, handler)
}

func _Warpdrive_SetupReleaseAdminCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Release)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WarpdriveServer).SetupReleaseAdminCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/warpdrive.Warpdrive/SetupReleaseAdminCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WarpdriveServer).SetupReleaseAdminCertificate(ctx, req.(*Release))
	}
	return interceptor(ctx, in, info, handler)
}

func _Warpdrive_SetupReleaseUserCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Release)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WarpdriveServer).SetupReleaseUserCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/warpdrive.Warpdrive/SetupReleaseUserCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WarpdriveServer).SetupReleaseUserCertificate(ctx, req.(*Release))
	}
	return interceptor(ctx, in, info, handler)
}

func _Warpdrive_Publish_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WarpdriveServer).Publish(&warpdrivePublishServer{stream})
}

type Warpdrive_PublishServer interface {
	SendAndClose(*Bundle) error
	Recv() (*Chunck, error)
	grpc.ServerStream
}

type warpdrivePublishServer struct {
	grpc.ServerStream
}

func (x *warpdrivePublishServer) SendAndClose(m *Bundle) error {
	return x.ServerStream.SendMsg(m)
}

func (x *warpdrivePublishServer) Recv() (*Chunck, error) {
	m := new(Chunck)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Warpdrive_Download_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Release)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WarpdriveServer).Download(m, &warpdriveDownloadServer{stream})
}

type Warpdrive_DownloadServer interface {
	Send(*Chunck) error
	grpc.ServerStream
}

type warpdriveDownloadServer struct {
	grpc.ServerStream
}

func (x *warpdriveDownloadServer) Send(m *Chunck) error {
	return x.ServerStream.SendMsg(m)
}

var _Warpdrive_serviceDesc = grpc.ServiceDesc{
	ServiceName: "warpdrive.Warpdrive",
	HandlerType: (*WarpdriveServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "setupApp",
			Handler:    _Warpdrive_SetupApp_Handler,
		},
		{
			MethodName: "setupReleaseAdminCertificate",
			Handler:    _Warpdrive_SetupReleaseAdminCertificate_Handler,
		},
		{
			MethodName: "setupReleaseUserCertificate",
			Handler:    _Warpdrive_SetupReleaseUserCertificate_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "publish",
			Handler:       _Warpdrive_Publish_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "download",
			Handler:       _Warpdrive_Download_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/warpdrive.proto",
}

func init() { proto.RegisterFile("proto/warpdrive.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 498 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x93, 0xcf, 0x6e, 0xd3, 0x40,
	0x10, 0xc6, 0x6d, 0xc7, 0x89, 0x9d, 0x09, 0xaa, 0xc2, 0x92, 0x22, 0x2b, 0xf4, 0x50, 0xf9, 0x14,
	0x40, 0xb4, 0x28, 0x15, 0x27, 0x4e, 0x69, 0x7a, 0x68, 0x14, 0xe4, 0xc0, 0xd2, 0xaa, 0x37, 0xa4,
	0x4d, 0x76, 0xab, 0x5a, 0x75, 0xec, 0xd5, 0x7a, 0x9d, 0xf0, 0x22, 0x3c, 0x17, 0xaf, 0x84, 0xf6,
	0x8f, 0x13, 0x43, 0x2a, 0x0e, 0xbd, 0xed, 0x37, 0xbb, 0xf3, 0x9b, 0xcf, 0x33, 0x63, 0x38, 0xe6,
	0xa2, 0x90, 0xc5, 0xf9, 0x96, 0x08, 0x4e, 0x45, 0xba, 0x61, 0x67, 0x5a, 0xa3, 0xee, 0x2e, 0x10,
	0xff, 0x00, 0x98, 0x0a, 0x46, 0x59, 0x2e, 0x53, 0x92, 0xa1, 0x21, 0x84, 0x55, 0xc9, 0x44, 0x4e,
	0xd6, 0x2c, 0x72, 0x4f, 0xdd, 0x51, 0x17, 0xef, 0xb4, 0xba, 0xe3, 0xa4, 0x2c, 0xb7, 0x85, 0xa0,
	0x91, 0x67, 0xee, 0x6a, 0x8d, 0x22, 0x08, 0x08, 0xe7, 0x89, 0x4a, 0x6b, 0xe9, 0xab, 0x5a, 0xc6,
	0x73, 0xe8, 0x4d, 0x99, 0x90, 0xe9, 0x7d, 0xba, 0x22, 0x92, 0xa1, 0x01, 0xb4, 0x65, 0xf1, 0xc8,
	0x72, 0x4b, 0x37, 0x02, 0x21, 0xf0, 0x57, 0x4c, 0x48, 0x8b, 0xd5, 0x67, 0x15, 0x23, 0x94, 0x0a,
	0xcb, 0xd3, 0xe7, 0xf8, 0x1b, 0xb4, 0x6f, 0x74, 0xc2, 0x00, 0xda, 0x84, 0xae, 0x53, 0x83, 0x09,
	0xb1, 0x11, 0x3a, 0xca, 0xf9, 0xcc, 0xd8, 0xf3, 0xb1, 0x11, 0xe8, 0x04, 0xba, 0x82, 0x65, 0x8c,
	0x94, 0x6c, 0x46, 0x35, 0xcd, 0xc7, 0xfb, 0x40, 0xfc, 0x16, 0x5a, 0x13, 0xce, 0xd1, 0x11, 0x78,
	0x29, 0xd5, 0x34, 0x1f, 0x7b, 0x29, 0x55, 0xd5, 0x75, 0x13, 0xac, 0x23, 0x75, 0x8e, 0xa7, 0x10,
	0x60, 0x93, 0x77, 0xf0, 0xfc, 0xe9, 0xca, 0x35, 0xa4, 0xd5, 0x80, 0xfc, 0x72, 0xa1, 0x73, 0x59,
	0xe5, 0x34, 0x3b, 0x84, 0xfc, 0x65, 0xd4, 0xfb, 0xc7, 0xa8, 0x86, 0xb1, 0x9f, 0xd2, 0x7e, 0x81,
	0x3e, 0xa3, 0x73, 0x08, 0x79, 0x46, 0xe4, 0x7d, 0x21, 0xd6, 0x91, 0x7f, 0xea, 0x8e, 0x8e, 0xc6,
	0xaf, 0xce, 0xf6, 0xb3, 0xfe, 0x6a, 0xaf, 0xf0, 0xee, 0x91, 0x9a, 0xd3, 0x86, 0x89, 0x32, 0x2d,
	0xf2, 0xa8, 0x6d, 0xe6, 0x64, 0x65, 0x7c, 0x03, 0x9d, 0xe9, 0x43, 0x95, 0xaf, 0x1e, 0xd1, 0x7b,
	0xe8, 0x2c, 0xb5, 0x41, 0x6d, 0xad, 0x37, 0x7e, 0xd9, 0x40, 0x1a, 0xe7, 0xd7, 0x0e, 0xb6, 0x4f,
	0xd0, 0x00, 0x7c, 0x4a, 0x24, 0xd1, 0x76, 0x5f, 0x5c, 0x3b, 0x58, 0xab, 0xcb, 0x00, 0xda, 0x1b,
	0x92, 0x55, 0xec, 0xdd, 0x07, 0x08, 0x6b, 0x17, 0xa8, 0x07, 0xc1, 0x6d, 0x32, 0x4f, 0x16, 0x77,
	0x49, 0xdf, 0x41, 0x01, 0xb4, 0x66, 0x8b, 0xef, 0x7d, 0x57, 0x45, 0x27, 0xc9, 0x15, 0x5e, 0xcc,
	0xae, 0xfa, 0xde, 0xf8, 0xb7, 0x07, 0xdd, 0xbb, 0xba, 0x18, 0xfa, 0x0c, 0x61, 0xc9, 0x64, 0xc5,
	0xd5, 0x7c, 0x8e, 0x1b, 0x26, 0xf6, 0xfb, 0x3a, 0x7c, 0xdd, 0x0c, 0xef, 0xd7, 0x2c, 0x76, 0xd0,
	0x17, 0x38, 0xd1, 0xc9, 0x76, 0x62, 0x13, 0xb5, 0x20, 0xcd, 0x45, 0x44, 0x8d, 0x4c, 0xfb, 0xe6,
	0x3f, 0xb4, 0x39, 0xbc, 0x69, 0xd2, 0x6e, 0x4b, 0x26, 0x9e, 0x0f, 0xbb, 0x80, 0x80, 0x57, 0xcb,
	0x2c, 0x2d, 0x1f, 0x50, 0xb3, 0xb7, 0xa6, 0xfd, 0xc3, 0xc3, 0x76, 0xc7, 0xce, 0xc8, 0x45, 0x9f,
	0x20, 0xa4, 0xc5, 0x36, 0xcf, 0x0a, 0x42, 0x9f, 0x2c, 0x77, 0x48, 0x8a, 0x9d, 0x8f, 0xee, 0xb2,
	0xa3, 0x7f, 0xf8, 0x8b, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xd4, 0x5a, 0xba, 0xd9, 0x09, 0x04,
	0x00, 0x00,
}
